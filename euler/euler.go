package euler

import (
	"math"
	"math/big"
	"strconv"
	"time"
)

// If we list all the natural numbers below 10 that are multiples of 3 or 5, we
// get 3, 5, 6 and 9. The sum of these multiples is 23.
//
// Find the sum of all the multiples of 3 or 5 below 1000.
func Problem001() int {
	var sum int
	for i := 1; i < 1000; i++ {
		if i%3 == 0 || i%5 == 0 {
			sum += i
		}
	}
	return sum
}

// Each new term in the Fibonacci sequence is generated by adding the previous
// two terms. By starting with 1 and 2, the first 10 terms will be:
//
//     1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//
// By considering the terms in the Fibonacci sequence whose values do not
// exceed four million, find the sum of the even-valued terms.
func Problem002() int {
	var sum int
	a, b := 1, 1
	for a < 4e6 {
		if a%2 == 0 {
			sum += a
		}
		a, b = b, a+b
	}
	return sum
}

// The prime factors of 13195 are 5, 7, 13 and 29.
//
// What is the largest prime factor of the number 600851475143?
func Problem003() int64 {
	var num, max int64 = 600851475143, 1
	for _, n := range Factor(num) {
		if n > max {
			max = n
		}
	}
	return max
}

// A palindromic number reads the same both ways. The largest palindrome made
// from the product of two 2-digit numbers is 9009 = 91 × 99.
//
// Find the largest palindrome made from the product of two 3-digit numbers.
func Problem004() int {
	var max int
	for i := 100; i < 1000; i++ {
		for j := i; j < 1000; j++ {
			n := i * j
			if isPalindrome(strconv.Itoa(n)) && n > max {
				max = n
			}
		}
	}
	return max
}

func isPalindrome(s string) bool {
	return s == reverse(s)
}

func reverse(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

// 2520 is the smallest number that can be divided by each of the numbers from
// 1 to 10 without any remainder.
//
// What is the smallest positive number that is evenly divisible by all of the
// numbers from 1 to 20?
func Problem005() int64 {
	factors := make(map[int64]int)

	var i int64
	for i = 1; i <= 20; i++ {
		count := make(map[int64]int)
		for _, v := range Factor(i) {
			count[v]++
		}

		for k := range count {
			if factors[k] < count[k] {
				factors[k] = count[k]
			}
		}
	}

	var answer int64 = 1
	for base, power := range factors {
		for i := 0; i < power; i++ {
			answer *= base
		}
	}

	return answer
}

// The sum of the squares of the first ten natural numbers is,
//     1² + 2² + ... + 10² = 385
//
// The square of the sum of the first ten natural numbers is,
//     (1 + 2 + ... + 10)² = 55² = 3025
//
// Hence the difference between the sum of the squares of the first ten natural
// numbers and the square of the sum is 3025 - 385 = 2640.
//
// Find the difference between the sum of the squares of the first one hundred
// natural numbers and the square of the sum.
func Problem006() int {
	var sum, sumOfSquares int
	for i := 1; i <= 100; i++ {
		sum += i
		sumOfSquares += i * i
	}
	return sum*sum - sumOfSquares
}

// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
// that the 6th prime is 13.
//
// What is the 10,001st prime number?
func Problem007() int64 {
	done := make(chan struct{})
	defer close(done)
	primes := Primes(done)
	for i := 0; i < 10000; i++ {
		<-primes
	}
	return <-primes
}

const num = "73167176531330624919225119674426574742355349194934" +
	"96983520312774506326239578318016984801869478851843" +
	"85861560789112949495459501737958331952853208805511" +
	"12540698747158523863050715693290963295227443043557" +
	"66896648950445244523161731856403098711121722383113" +
	"62229893423380308135336276614282806444486645238749" +
	"30358907296290491560440772390713810515859307960866" +
	"70172427121883998797908792274921901699720888093776" +
	"65727333001053367881220235421809751254540594752243" +
	"52584907711670556013604839586446706324415722155397" +
	"53697817977846174064955149290862569321978468622482" +
	"83972241375657056057490261407972968652414535100474" +
	"82166370484403199890008895243450658541227588666881" +
	"16427171479924442928230863465674813919123162824586" +
	"17866458359124566529476545682848912883142607690042" +
	"24219022671055626321111109370544217506941658960408" +
	"07198403850962455444362981230987879927244284909188" +
	"84580156166097919133875499200524063689912560717606" +
	"05886116467109405077541002256983155200055935729725" +
	"71636269561882670428252483600823257530420752963450"

// Find the greatest product of five consecutive digits in the 1000-digit
// number.
//
//     73167176531330624919225119674426574742355349194934
//     96983520312774506326239578318016984801869478851843
//     85861560789112949495459501737958331952853208805511
//     12540698747158523863050715693290963295227443043557
//     66896648950445244523161731856403098711121722383113
//     62229893423380308135336276614282806444486645238749
//     30358907296290491560440772390713810515859307960866
//     70172427121883998797908792274921901699720888093776
//     65727333001053367881220235421809751254540594752243
//     52584907711670556013604839586446706324415722155397
//     53697817977846174064955149290862569321978468622482
//     83972241375657056057490261407972968652414535100474
//     82166370484403199890008895243450658541227588666881
//     16427171479924442928230863465674813919123162824586
//     17866458359124566529476545682848912883142607690042
//     24219022671055626321111109370544217506941658960408
//     07198403850962455444362981230987879927244284909188
//     84580156166097919133875499200524063689912560717606
//     05886116467109405077541002256983155200055935729725
//     71636269561882670428252483600823257530420752963450
func Problem008() int {
	var max, product int32
	rs := []rune(num)
	for i, j := 0, 5; j <= 1000; i, j = i+1, j+1 {
		product = 1
		for _, v := range rs[i:j] {
			product *= v - '0'
		}
		if product > max {
			max = product
		}
	}
	return int(max)
}

// A Pythagorean triplet is a set of three natural numbers, a < b < c, for
// which,
//     a² + b² = c²
//
// For example, 3² + 4² = 9 + 16 = 25 = 5².
//
// There exists exactly one Pythagorean triplet for which a + b + c = 1000.
// Find the product abc.
func Problem009() int {
	// c must be greater than 1000/3 to satisfy a < b < c and
	// a + b + c = 1000, and less than 1000/2 because no side
	// of a triangle can have length greater than half the
	// circumference.
	for c := 335; c < 500; c++ {
		for b := (1000 - c) / 2; b < c; b++ {
			a := 1000 - b - c
			if a*a+b*b == c*c {
				return a * b * c
			}
		}
	}
	panic("whaa!!")
}

// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
//
// Find the sum of all the primes below two million.
func Problem010() int64 {
	done := make(chan struct{})
	defer close(done)
	primes := Primes(done)
	var sum int64
	for i := <-primes; i < 2e6; i = <-primes {
		sum += i
	}
	return sum
}

// In the 20×20 grid below, four numbers along a diagonal line have been marked
// with angled brackets.
//
//     08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
//     49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
//     81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
//     52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
//     22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
//     24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
//     32 98 81 28 64 23 67 10<26>38 40 67 59 54 70 66 18 38 64 70
//     67 26 20 68 02 62 12 20 95<63>94 39 63 08 40 91 66 49 94 21
//     24 55 58 05 66 73 99 26 97 17<78>78 96 83 14 88 34 89 63 72
//     21 36 23 09 75 00 76 44 20 45 35<14>00 61 33 97 34 31 33 95
//     78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
//     16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
//     86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
//     19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
//     04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
//     88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
//     04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
//     20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
//     20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
//     01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
//
// The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
//
// What is the greatest product of four adjacent numbers in the same direction
// (up, down, left, right, or diagonally) in the 20×20 grid?
func Problem011() int {
	var max int

	for r := range grid {
		for c := range grid[r] {
			// vertical
			if r <= rows-4 {
				product := grid[r][c] * grid[r+1][c] * grid[r+2][c] * grid[r+3][c]
				if product > max {
					max = product
				}
			}
			// horizontal
			if c <= columns-4 {
				product := grid[r][c] * grid[r][c+1] * grid[r][c+2] * grid[r][c+3]
				if product > max {
					max = product
				}
			}
			// diagonal (right+down)
			if r <= rows-4 && c <= columns-4 {
				product := grid[r][c] * grid[r+1][c+1] * grid[r+2][c+2] * grid[r+3][c+3]
				if product > max {
					max = product
				}
			}
			// diagonal (left+down)
			if r <= rows-4 && c >= 3 {
				product := grid[r][c] * grid[r+1][c-1] * grid[r+2][c-2] * grid[r+3][c-3]
				if product > max {
					max = product
				}
			}
		}
	}

	return max
}

const (
	rows    = 20
	columns = 20
)

var grid = [rows][columns]int{
	{8, 2, 22, 97, 38, 15, 0, 40, 0, 75, 4, 5, 7, 78, 52, 12, 50, 77, 91, 8},
	{49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 4, 56, 62, 0},
	{81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 3, 49, 13, 36, 65},
	{52, 70, 95, 23, 4, 60, 11, 42, 69, 24, 68, 56, 1, 32, 56, 71, 37, 2, 36, 91},
	{22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80},
	{24, 47, 32, 60, 99, 3, 45, 2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50},
	{32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70},
	{67, 26, 20, 68, 2, 62, 12, 20, 95, 63, 94, 39, 63, 8, 40, 91, 66, 49, 94, 21},
	{24, 55, 58, 5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72},
	{21, 36, 23, 9, 75, 0, 76, 44, 20, 45, 35, 14, 0, 61, 33, 97, 34, 31, 33, 95},
	{78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 3, 80, 4, 62, 16, 14, 9, 53, 56, 92},
	{16, 39, 5, 42, 96, 35, 31, 47, 55, 58, 88, 24, 0, 17, 54, 24, 36, 29, 85, 57},
	{86, 56, 0, 48, 35, 71, 89, 7, 5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58},
	{19, 80, 81, 68, 5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 4, 89, 55, 40},
	{4, 52, 8, 83, 97, 35, 99, 16, 7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66},
	{88, 36, 68, 87, 57, 62, 20, 72, 3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69},
	{4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 8, 46, 29, 32, 40, 62, 76, 36},
	{20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 4, 36, 16},
	{20, 73, 35, 29, 78, 31, 90, 1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 5, 54},
	{1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 1, 89, 19, 67, 48},
}

func triangleNums() <-chan int64 {
	ch := make(chan int64)
	go func() {
		var sum int64 = 0
		for i := int64(1); ; i++ {
			sum += i
			ch <- sum
		}
	}()
	return ch
}

func numDivisors(n int64) int {
	factors := Factor(n)
	counts := make(map[int64]int)
	var product int = 1
	for _, v := range factors {
		counts[v]++
	}
	for _, v := range counts {
		product *= v + 1
	}
	return product
}

// The sequence of triangle numbers is generated by adding the natural numbers.
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The
// first ten terms would be:
//
//     1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
//
// Let us list the factors of the first seven triangle numbers:
//
//      1: 1
//      3: 1,3
//      6: 1,2,3,6
//     10: 1,2,5,10
//     15: 1,3,5,15
//     21: 1,3,7,21
//     28: 1,2,4,7,14,28
//
// We can see that 28 is the first triangle number to have over five divisors.
//
// What is the value of the first triangle number to have over five hundred
// divisors?
func Problem012() int64 {
	for v := range triangleNums() {
		if numDivisors(v) > 500 {
			return v
		}
	}
	panic("???")
}

// Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
//
//     37107287533902102798797998220837590246510135740250
//     46376937677490009712648124896970078050417018260538
//     74324986199524741059474233309513058123726617309629
//     91942213363574161572522430563301811072406154908250
//     23067588207539346171171980310421047513778063246676
//     89261670696623633820136378418383684178734361726757
//     28112879812849979408065481931592621691275889832738
//     44274228917432520321923589422876796487670272189318
//     47451445736001306439091167216856844588711603153276
//     70386486105843025439939619828917593665686757934951
//     62176457141856560629502157223196586755079324193331
//     64906352462741904929101432445813822663347944758178
//     92575867718337217661963751590579239728245598838407
//     58203565325359399008402633568948830189458628227828
//     80181199384826282014278194139940567587151170094390
//     35398664372827112653829987240784473053190104293586
//     86515506006295864861532075273371959191420517255829
//     71693888707715466499115593487603532921714970056938
//     54370070576826684624621495650076471787294438377604
//     53282654108756828443191190634694037855217779295145
//     36123272525000296071075082563815656710885258350721
//     45876576172410976447339110607218265236877223636045
//     17423706905851860660448207621209813287860733969412
//     81142660418086830619328460811191061556940512689692
//     51934325451728388641918047049293215058642563049483
//     62467221648435076201727918039944693004732956340691
//     15732444386908125794514089057706229429197107928209
//     55037687525678773091862540744969844508330393682126
//     18336384825330154686196124348767681297534375946515
//     80386287592878490201521685554828717201219257766954
//     78182833757993103614740356856449095527097864797581
//     16726320100436897842553539920931837441497806860984
//     48403098129077791799088218795327364475675590848030
//     87086987551392711854517078544161852424320693150332
//     59959406895756536782107074926966537676326235447210
//     69793950679652694742597709739166693763042633987085
//     41052684708299085211399427365734116182760315001271
//     65378607361501080857009149939512557028198746004375
//     35829035317434717326932123578154982629742552737307
//     94953759765105305946966067683156574377167401875275
//     88902802571733229619176668713819931811048770190271
//     25267680276078003013678680992525463401061632866526
//     36270218540497705585629946580636237993140746255962
//     24074486908231174977792365466257246923322810917141
//     91430288197103288597806669760892938638285025333403
//     34413065578016127815921815005561868836468420090470
//     23053081172816430487623791969842487255036638784583
//     11487696932154902810424020138335124462181441773470
//     63783299490636259666498587618221225225512486764533
//     67720186971698544312419572409913959008952310058822
//     95548255300263520781532296796249481641953868218774
//     76085327132285723110424803456124867697064507995236
//     37774242535411291684276865538926205024910326572967
//     23701913275725675285653248258265463092207058596522
//     29798860272258331913126375147341994889534765745501
//     18495701454879288984856827726077713721403798879715
//     38298203783031473527721580348144513491373226651381
//     34829543829199918180278916522431027392251122869539
//     40957953066405232632538044100059654939159879593635
//     29746152185502371307642255121183693803580388584903
//     41698116222072977186158236678424689157993532961922
//     62467957194401269043877107275048102390895523597457
//     23189706772547915061505504953922979530901129967519
//     86188088225875314529584099251203829009407770775672
//     11306739708304724483816533873502340845647058077308
//     82959174767140363198008187129011875491310547126581
//     97623331044818386269515456334926366572897563400500
//     42846280183517070527831839425882145521227251250327
//     55121603546981200581762165212827652751691296897789
//     32238195734329339946437501907836945765883352399886
//     75506164965184775180738168837861091527357929701337
//     62177842752192623401942399639168044983993173312731
//     32924185707147349566916674687634660915035914677504
//     99518671430235219628894890102423325116913619626622
//     73267460800591547471830798392868535206946944540724
//     76841822524674417161514036427982273348055556214818
//     97142617910342598647204516893989422179826088076852
//     87783646182799346313767754307809363333018982642090
//     10848802521674670883215120185883543223812876952786
//     71329612474782464538636993009049310363619763878039
//     62184073572399794223406235393808339651327408011116
//     66627891981488087797941876876144230030984490851411
//     60661826293682836764744779239180335110989069790714
//     85786944089552990653640447425576083659976645795096
//     66024396409905389607120198219976047599490197230297
//     64913982680032973156037120041377903785566085089252
//     16730939319872750275468906903707539413042652315011
//     94809377245048795150954100921645863754710598436791
//     78639167021187492431995700641917969777599028300699
//     15368713711936614952811305876380278410754449733078
//     40789923115535562561142322423255033685442488917353
//     44889911501440648020369068063960672322193204149535
//     41503128880339536053299340368006977710650566631954
//     81234880673210146739058568557934581403627822703280
//     82616570773948327592232845941706525094512325230608
//     22918802058777319719839450180888072429661980811197
//     77158542502016545090413245809786882778948721859617
//     72107838435069186155435662884062257473692284509516
//     20849603980134001723930671666823555245252804609722
//     53503534226472524250874054075591789781264330331690
func Problem013() string {
	sum := big.NewInt(0)
	for i := range addends {
		addend, _ := big.NewInt(0).SetString(addends[i], 10)
		sum.Add(sum, addend)
	}

	return sum.String()[0:10]
}

var addends = []string{
	"37107287533902102798797998220837590246510135740250",
	"46376937677490009712648124896970078050417018260538",
	"74324986199524741059474233309513058123726617309629",
	"91942213363574161572522430563301811072406154908250",
	"23067588207539346171171980310421047513778063246676",
	"89261670696623633820136378418383684178734361726757",
	"28112879812849979408065481931592621691275889832738",
	"44274228917432520321923589422876796487670272189318",
	"47451445736001306439091167216856844588711603153276",
	"70386486105843025439939619828917593665686757934951",
	"62176457141856560629502157223196586755079324193331",
	"64906352462741904929101432445813822663347944758178",
	"92575867718337217661963751590579239728245598838407",
	"58203565325359399008402633568948830189458628227828",
	"80181199384826282014278194139940567587151170094390",
	"35398664372827112653829987240784473053190104293586",
	"86515506006295864861532075273371959191420517255829",
	"71693888707715466499115593487603532921714970056938",
	"54370070576826684624621495650076471787294438377604",
	"53282654108756828443191190634694037855217779295145",
	"36123272525000296071075082563815656710885258350721",
	"45876576172410976447339110607218265236877223636045",
	"17423706905851860660448207621209813287860733969412",
	"81142660418086830619328460811191061556940512689692",
	"51934325451728388641918047049293215058642563049483",
	"62467221648435076201727918039944693004732956340691",
	"15732444386908125794514089057706229429197107928209",
	"55037687525678773091862540744969844508330393682126",
	"18336384825330154686196124348767681297534375946515",
	"80386287592878490201521685554828717201219257766954",
	"78182833757993103614740356856449095527097864797581",
	"16726320100436897842553539920931837441497806860984",
	"48403098129077791799088218795327364475675590848030",
	"87086987551392711854517078544161852424320693150332",
	"59959406895756536782107074926966537676326235447210",
	"69793950679652694742597709739166693763042633987085",
	"41052684708299085211399427365734116182760315001271",
	"65378607361501080857009149939512557028198746004375",
	"35829035317434717326932123578154982629742552737307",
	"94953759765105305946966067683156574377167401875275",
	"88902802571733229619176668713819931811048770190271",
	"25267680276078003013678680992525463401061632866526",
	"36270218540497705585629946580636237993140746255962",
	"24074486908231174977792365466257246923322810917141",
	"91430288197103288597806669760892938638285025333403",
	"34413065578016127815921815005561868836468420090470",
	"23053081172816430487623791969842487255036638784583",
	"11487696932154902810424020138335124462181441773470",
	"63783299490636259666498587618221225225512486764533",
	"67720186971698544312419572409913959008952310058822",
	"95548255300263520781532296796249481641953868218774",
	"76085327132285723110424803456124867697064507995236",
	"37774242535411291684276865538926205024910326572967",
	"23701913275725675285653248258265463092207058596522",
	"29798860272258331913126375147341994889534765745501",
	"18495701454879288984856827726077713721403798879715",
	"38298203783031473527721580348144513491373226651381",
	"34829543829199918180278916522431027392251122869539",
	"40957953066405232632538044100059654939159879593635",
	"29746152185502371307642255121183693803580388584903",
	"41698116222072977186158236678424689157993532961922",
	"62467957194401269043877107275048102390895523597457",
	"23189706772547915061505504953922979530901129967519",
	"86188088225875314529584099251203829009407770775672",
	"11306739708304724483816533873502340845647058077308",
	"82959174767140363198008187129011875491310547126581",
	"97623331044818386269515456334926366572897563400500",
	"42846280183517070527831839425882145521227251250327",
	"55121603546981200581762165212827652751691296897789",
	"32238195734329339946437501907836945765883352399886",
	"75506164965184775180738168837861091527357929701337",
	"62177842752192623401942399639168044983993173312731",
	"32924185707147349566916674687634660915035914677504",
	"99518671430235219628894890102423325116913619626622",
	"73267460800591547471830798392868535206946944540724",
	"76841822524674417161514036427982273348055556214818",
	"97142617910342598647204516893989422179826088076852",
	"87783646182799346313767754307809363333018982642090",
	"10848802521674670883215120185883543223812876952786",
	"71329612474782464538636993009049310363619763878039",
	"62184073572399794223406235393808339651327408011116",
	"66627891981488087797941876876144230030984490851411",
	"60661826293682836764744779239180335110989069790714",
	"85786944089552990653640447425576083659976645795096",
	"66024396409905389607120198219976047599490197230297",
	"64913982680032973156037120041377903785566085089252",
	"16730939319872750275468906903707539413042652315011",
	"94809377245048795150954100921645863754710598436791",
	"78639167021187492431995700641917969777599028300699",
	"15368713711936614952811305876380278410754449733078",
	"40789923115535562561142322423255033685442488917353",
	"44889911501440648020369068063960672322193204149535",
	"41503128880339536053299340368006977710650566631954",
	"81234880673210146739058568557934581403627822703280",
	"82616570773948327592232845941706525094512325230608",
	"22918802058777319719839450180888072429661980811197",
	"77158542502016545090413245809786882778948721859617",
	"72107838435069186155435662884062257473692284509516",
	"20849603980134001723930671666823555245252804609722",
	"53503534226472524250874054075591789781264330331690",
}

var memoCollatz = make(map[int64]int64)

func numCollatz(n int64) int64 {
	seq := []int64{n}
	count := int64(1)
	for n != 1 {
		if v, ok := memoCollatz[n]; ok {
			count += v
			break
		} else if n%2 == 0 {
			n /= 2
		} else {
			n = 3*n + 1
		}
		seq = append(seq, n)
		count++
	}
	for i := 0; i < len(seq); i++ {
		memoCollatz[seq[i]] = count
		count--
	}
	return memoCollatz[seq[0]]
}

// The following iterative sequence is defined for the set of positive
// integers:
//
//     n → n/2 (n is even)
//     n → 3n + 1 (n is odd)
//
// Using the rule above and starting with 13, we generate the following
// sequence:
//
//     13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
//
// It can be seen that this sequence (starting at 13 and finishing at 1)
// contains 10 terms. Although it has not been proved yet (Collatz Problem), it
// is thought that all starting numbers finish at 1.
//
// Which starting number, under one million, produces the longest chain?
//
// NOTE: Once the chain starts the terms are allowed to go above one million.
func Problem014() int64 {
	var max, maxStart int64
	for i := int64(1); i < 1000000; i++ {
		n := numCollatz(i)
		if n > max {
			max = n
			maxStart = i
		}
	}
	return maxStart
}

// 2¹⁵ = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
//
// What is the sum of the digits of the number 2¹⁰⁰⁰?
func Problem016() int {
	var sum int

	power := big.NewInt(1)
	two := big.NewInt(2)
	for i := 0; i < 1000; i++ {
		power.Mul(power, two)
	}

	for _, r := range power.String() {
		digit := int(r - '0')
		sum += digit
	}

	return sum
}

// If the numbers 1 to 5 are written out in words: one, two, three, four, five,
// then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
//
// If all the numbers from 1 to 1000 (one thousand) inclusive were written out
// in words, how many letters would be used?
//
// NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and
// forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20
// letters. The use of "and" when writing out numbers is in compliance with
// British usage.
func Problem017() int {
	var count int

	for i := 1; i <= 1000; i++ {
		for _, r := range Cardinal(i) {
			switch r {
			case ' ', '-':
			default:
				count++
			}
		}
	}

	return count
}

var cardinals = map[int]string{
	0:  "zero",
	1:  "one",
	2:  "two",
	3:  "three",
	4:  "four",
	5:  "five",
	6:  "six",
	7:  "seven",
	8:  "eight",
	9:  "nine",
	10: "ten",
	11: "eleven",
	12: "twelve",
	13: "thirteen",
	14: "fourteen",
	15: "fifteen",
	16: "sixteen",
	17: "seventeen",
	18: "eighteen",
	19: "nineteen",
	20: "twenty",
	30: "thirty",
	40: "forty",
	50: "fifty",
	60: "sixty",
	70: "seventy",
	80: "eighty",
	90: "ninety",
}

func Cardinal(n int) string {
	var s string

	if !(0 <= n && n <= 9999) {
		panic("Cardinal: n not between 0 and 9999.")
	}

	if cardinal, ok := cardinals[n]; ok {
		return cardinal
	}

	thousands := n / 1000
	n %= 1000
	if thousands > 0 {
		s += cardinals[thousands] + " thousand"
		if n > 0 {
			s += " "
		}
	}

	hundreds := n / 100
	n %= 100
	if hundreds > 0 {
		s += cardinals[hundreds] + " hundred"
		if n > 0 {
			s += " and "
		}
	}

	tens := n / 10
	n %= 10
	if tens == 1 {
		s += cardinals[tens*10+n]
		return s
	} else if tens > 0 {
		s += cardinals[tens*10]
		if n > 0 {
			s += "-"
		}
	}

	ones := n
	if ones > 0 {
		s += cardinals[ones]
	}

	return s
}

// You are given the following information, but you may prefer to do some
// research for yourself.
//
//     * 1 Jan 1900 was a Monday.
//     * Thirty days has September,
//       April, June and November.
//       All the rest have thirty-one,
//       Saving February alone,
//       Which has twenty-eight, rain or shine.
//       And on leap years, twenty-nine.
//     * A leap year occurs on any year evenly divisible by 4, but not on a
//       century unless it is divisible by 400.
//
// How many Sundays fell on the first of the month during the twentieth century
// (1 Jan 1901 to 31 Dec 2000)?
func Problem019() int {
	var count int

	for year := 1901; year <= 2000; year++ {
		for month := time.Month(1); month <= 12; month++ {
			firstOfTheMonth := time.Date(year, month, 1, 0, 0, 0, 0, time.UTC)
			if firstOfTheMonth.Weekday() == time.Sunday {
				count++
			}
		}
	}

	return count
}

// n! means n × (n - 1) × ... × 3 × 2 × 1
//
// For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
// and the sum of the digits in the number 10! is
// 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
//
// Find the sum of the digits in the number 100!
func Problem020() int {
	digits := []rune(Factorial(100).String())
	var sum int32
	for i := range digits {
		sum += digits[i] - '0'
	}
	return int(sum)
}

// BUG(me): 64-bit uints?
func Factorial(n uint) *big.Int {
	return big.NewInt(1).MulRange(1, int64(n))
}

// A permutation is an ordered arrangement of objects. For example, 3124 is one
// possible permutation of the digits 1, 2, 3 and 4. If all of the permutations
// are listed numerically or alphabetically, we call it lexicographic order.
// The lexicographic permutations of 0, 1 and 2 are:
//
//     012  021  102  120  201  210
//
// What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4,
// 5, 6, 7, 8 and 9?
func Problem024() string {
	digits := NthPermutation(1e6-1, 10)
	b := make([]byte, 10)
	for i := 0; i < len(digits); i++ {
		b[i] = byte(digits[i] + '0')
	}
	return string(b)
}

// NthPermutation returns the nth lexicographic permutation of the integers
// [0,degree).
func NthPermutation(n, degree int) []int {
	f := newFactoradic(n, degree)

	tmp := make([]int, degree)
	for i := 0; i < degree; i++ {
		tmp[i] = i
	}

	slice := make([]int, degree)
	for i := range slice {
		slice[i] = tmp[f[i]]
		tmp = rmElem(f[i], tmp)
	}

	return slice
}

func newFactoradic(x, nDigits int) []int {
	f := make([]int, nDigits)
	for i := range f {
		placeValue := factorial(nDigits - 1 - i)
		f[i] = x / placeValue
		x %= placeValue
	}

	return f
}

func factorial(n int) int {
	product := 1
	for i := 1; i <= n; i++ {
		product *= i
	}
	return product
}

func rmElem(index int, slice []int) []int {
	for i := index + 1; i < len(slice); i++ {
		slice[i-1] = slice[i]
	}
	return slice[:len(slice)-1]
}

// The Fibonacci sequence is defined by the recurrence relation:
//
//     Fₙ = Fₙ₋₁ + Fₙ₋₂, where F₁ = 1 and F₂ = 1.
//
// Hence the first 12 terms will be:
//
//     F₁ = 1
//     F₂ = 1
//     F₃ = 2
//     F₄ = 3
//     F₅ = 5
//     F₆ = 8
//     F₇ = 13
//     F₈ = 21
//     F₉ = 34
//     F₁₀ = 55
//     F₁₁ = 89
//     F₁₂ = 144
//
// The 12th term, F₁₂, is the first term to contain three digits.
//
// What is the first term in the Fibonacci sequence to contain 1000 digits?
func Problem025() int {
	a, b := big.NewInt(0), big.NewInt(1)
	var i int
	for i = 0; len(a.String()) < 1000; i++ {
		a, b = b, big.NewInt(1).Add(a, b)
	}
	return i
}

// Consider all integer combinations of aᵇ for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
//
//     2²=4,  2³=8,   2⁴=16,  2⁵=32
//     3²=9,  3³=27,  3⁴=81,  3⁵=243
//     4²=16, 4³=64,  4⁴=256, 4⁵=1024
//     5²=25, 5³=125, 5⁴=625, 5⁵=3125
//
// If they are then placed in numerical order, with any repeats removed, we get
// the following sequence of 15 distinct terms:
//
//     4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
//
// How many distinct terms are in the sequence generated by aᵇ for
// 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
func Problem029() int {
	set := make(map[string]struct{})
	var a, b int64
	for a = 2; a <= 100; a++ {
		for b = 2; b <= 100; b++ {
			// a**b
			power := big.NewInt(0).Exp(big.NewInt(a), big.NewInt(b), nil)
			set[power.String()] = struct{}{}
		}
	}
	return len(set)
}

// The decimal number, 585 = 1001001001₂ (binary), is palindromic in both
// bases.
//
// Find the sum of all numbers, less than one million, which are palindromic
// in base 10 and base 2.
//
// (Please note that the palindromic number, in either base, may not include
// leading zeros.)
func Problem036() int64 {
	var i, sum int64
	for i = 0; i < 1e6; i++ {
		decimal := strconv.FormatInt(i, 10)
		binary := strconv.FormatInt(i, 2)
		if isPalindrome(decimal) && isPalindrome(binary) {
			sum += i
		}
	}
	return sum
}

// The series, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.
//
// Find the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.
func Problem048() string {
	sum := big.NewInt(0)
	for i := 1; i <= 1000; i++ {
		bigI := big.NewInt(int64(i))
		power := big.NewInt(1)
		for j := 0; j < i; j++ {
			power.Mul(power, bigI)
		}
		sum.Add(sum, power)
	}
	s := sum.String()
	return s[len(s)-10:]
}

// generate sends a sequence of possible primes to ch, to be filtered later.
func generate(ch chan<- int64, done <-chan struct{}) {
	defer close(ch)

	// Send the first two primes
	for _, v := range [...]int64{2, 3} {
		select {
		case ch <- v:
		case <-done:
			return
		}
	}

	// After 2 and 3, every prime is a multiple of 6 +/- 1
	var n int64
	for n = 6; ; n += 6 {
		for _, v := range [...]int64{n - 1, n + 1} {
			select {
			case ch <- v:
			case <-done:
				return
			}
		}
	}
}

// filter copies values from in to out, removing those divisible by prime.
func filter(in <-chan int64, out chan<- int64, prime int64, x chan<- int64, done <-chan struct{}) {
	defer close(out)

	for v := range in {
		if prime > int64(math.Sqrt(float64(v))) {
			select {
			case x <- v:
			case <-done:
				return
			}
		} else if v%prime != 0 {
			select {
			case out <- v:
			case <-done:
				return
			}
		}
	}
}

// Primes returns a channel of successive prime numbers. Close the 'done' chan
// to clean up.
func Primes(done <-chan struct{}) <-chan int64 {
	primes := make(chan int64)

	go func(primes chan<- int64, done <-chan struct{}) {
		x := make(chan int64)
		ch1 := make(chan int64)
		go generate(ch1, done)
		for {
			var prime int64
			select {
			case prime = <-x:
			case prime = <-ch1:
			}

			select {
			case primes <- prime:
			case <-done:
				close(primes)
				return
			}

			ch2 := make(chan int64)
			go filter(ch1, ch2, prime, x, done)
			ch1 = ch2
		}
	}(primes, done)

	return primes
}

func Factor(n int64) []int64 {
	factors := make([]int64, 0)

	done := make(chan struct{})
	defer close(done)

	primes := Primes(done)
	for n > 1 {
		prime := <-primes
		for n%prime == 0 {
			factors = append(factors, prime)
			n /= prime
		}
	}

	return factors
}
